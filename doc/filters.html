<h1>Filters</h1>

<h2>Introduction</h2>

<p>In order to build complex filters, the system devised is to provide the
ability to build basic filters, based solely on conditions, and to the use
them in higher order filters.</p>

<p>Filters can be defined in three different places:</p>
<ul>
<li>in the server configuration file (global scope)</li>
<li>at the top of the client configuration file (client scope)</li>
<li>within a path section in the client configuration file (path scope)</li>
</ul>

<p>There is no namespace protection, so if two filters are defined with the
same name, the filter of most restricted scope is used: path, then client, then
global.</p>

<h2>Syntax</h2>

<p><code><pre>
filter &lt;filter type&gt; &lt;name&gt;
condition &lt;condition type&gt; &lt;value&gt;
...
</pre></code></p>

<h2>Conditions</h2>

<p>Conditions are the base of all filters. They are the individual conditions,
based on virtually any file metadata (path, name, type, size, ...) that put
together make a filter.</p>

<h3>Condition types</h3>

<p>All available conditions types are shown in the table below:</p>
<table border="1" width="100%">
  <tr>
    <td><b>Condition type</b></td>
    <td><b>Description</b></td>
    <td><b>Parameter type</b></td>
  </tr>
  <tr>
    <td>filter</td>
    <td>Subfilter</td>
    <td>string</td>
  </tr>
  <tr>
    <td>type</td>
    <td>File type</td>
    <td>character or string</td>
  </tr>
  <tr>
    <td>name</td>
    <td>Exact file name</td>
    <td>string</td>
  </tr>
  <tr>
    <td>name_start</td>
    <td>Start of file name</td>
    <td>string</td>
  </tr>
  <tr>
    <td>name_end</td>
    <td>End of file name</td>
    <td>string</td>
  </tr>
  <tr>
    <td>name_regex</td>
    <td>Regular expression on file name</td>
    <td>string</td>
  </tr>
  <tr>
    <td>path</td>
    <td>Exact path</td>
    <td>string</td>
  </tr>
  <tr>
    <td>path_start</td>
    <td>Start of path</td>
    <td>string</td>
  </tr>
  <tr>
    <td>path_end</td>
    <td>End of path</td>
    <td>string</td>
  </tr>
  <tr>
    <td>path_regex</td>
    <td>Regular expression on path</td>
    <td>string</td>
  </tr>
  <tr>
    <td>size_ge</td>
    <td>Minimum size (regular files only)</td>
    <td>decimal number</td>
  </tr>
  <tr>
    <td>size_gt</td>
    <td>Minimum size (regular files only)</td>
    <td>decimal number</td>
  </tr>
  <tr>
    <td>size_le</td>
    <td>Maximum size (regular files only)</td>
    <td>decimal number</td>
  </tr>
  <tr>
    <td>size_lt</td>
    <td>Maximum size (regular files only)</td>
    <td>decimal number</td>
  </tr>
  <!--
  <tr>
     <td>mode_and</td>
     <td>Mode contains some of the given mode bits</td>
    <td>octal number</td>
  </tr>
  <tr>
     <td>mode_eq</td>
     <td>Mode contains all of the given mode bits</td>
    <td>octal number</td>
  </tr>
  -->
</table>

<p>Note: conditions can be negated by placing the <code>!</code> (exclamation
mark) character in front of the condition name (no space allowed).</p>

<h3>File types</h3>

<p>All file types are shown below:</p>

<table border="1" width="100%">
  <tr>
    <td><b>File type</b></td>
    <td><b>Description</b></td>
  </tr>
  <tr>
    <td>file</td>
    <td>Regular file</td>
  </tr>
  <tr>
    <td>directory</td>
    <td>Directory</td>
  </tr>
  <tr>
    <td>link</td>
    <td>Symbolic link</td>
  </tr>
  <tr>
    <td>pipe</td>
    <td>Named pipe or FIFO</td>
  </tr>
  <tr>
    <td>socket</td>
    <td>Socket</td>
  </tr>
  <tr>
    <td>char</td>
    <td>Character device</td>
  </tr>
  <tr>
    <td>block</td>
    <td>Block device</td>
  </tr>
</table>

<p>Note: only the initial of the type matters, so <code>file</code> can be
replaced by <code>f</code> or <code>fi</code> or <code>fate</code> without
any change in behaviour.</p>

<h3>Examples</h3>

<p><code><pre>
# Size is strictly more than 10k
condition size&gt; 10000

# Name does not start in ml
condition !name_start ml

# File is a pipe
condition type p
</pre></code></p>

<h2>Filters</h2>

<p>There are two types of filters:</p>
<ul>
<li>ANY (a.k.a. OR) filters are a logical 'or' of its conditions and
  subfilters, so they match if any condition is true.</li>
<li>ALL (a.k.a AND) filters are a logical 'and' of its conditions and
  subfilters, so they only match if all conditions are true.</li>
</ul>

<h3>Basic filters</h3>

<p>Basic filters are filters that do not have subfilters and are based solely
on conditions. Here are two examples of basic filters:</p>

<p><code><pre>
# Basic ANY filter defining compressed archives
filter any compressed_archives
condition name_end .bz2
condition name_end .gz
condition name_end .zip

# Basic ALL filter defining big regular files
filter all big_files
condition type file
condition !size&lt; 1024
</pre></code></p>

<h3>Complex filters</h3>

<p>Complex filters are filters that have subfilters. Here is an example of a
complex filter:</p>

<p><code><pre>
# Filter defining files worth compressing
filter all worth_compressing
condition !filter compressed_archives
condition filter big_files
</pre></code></p>
