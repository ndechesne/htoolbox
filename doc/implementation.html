<h1>Implementation</h1>

<p>I shall try to explain below some implementation choices and details.</p>

<h2>Requirements</h2>

  <h3>Reliable</h3>
  <p>Good error management, recovery system</p>
  <ul>
  <li>errors are detected, and reported but not fatal wherever possible</li>
  <li>crash and cancellation are dealt with by the use of a journal</li>
  </ul>

  <h3>Fast</h3>
  <p>Efficient coding of most-used code</p>
  <ul>
  <li>C-structures are used for low-level classes and code</li>
  </ul>

  <h3>Small memory footprint</h3>
  <p>Keep as little data in memory as possible</p>
  <ul>
  <li>directories are parsed and compared to the backup DB contents list on
  the fly</li>
  <li>actions are taken immediately</li>
  </ul>

<h2>Programming language</h2>

<p>C++ seems to me a good compromise between C, where I would have to be very
careful wrt memory leaks and Python, where I was afraid performance might
become an issue. Also, I had some experience in C++ and none in Python, which
I still plan to learn :(</p>

<p>The OO concepts I mostly use in this software are default parameter value
and inheritance, very little polymorphism.</p>

<h2>Database requirements</h2>

<p>Why not a 'proper' DB? Simple: I have no use for 'SELECT'! I want to read
<i>all</i> elements in alphabetic order everytime and compare them to what is
being backed up. Really, I cannot use a standard DB.</p>

<h2>The classes</h2>

  <h3>Overview</h3>

  <p>The main class is Hbackup, which provides the functionality to MMIs.
  Hbackup has Clients. A client has mount Options and Paths to backup.</p>
  <p>Hbackup has global Filters, where as a Client has local filters and Path
  has specific filters. Paths also have Parsers (CVS, and more when I have
  time...).</p>
  <p>Filters have Conditions (which can be filters too).</p>
  <p>I use some specific string operations targeted at paths, especially for
  ordering purposes (somehow moving the '/' character between ASCII 31 and
  32).</p>
  <p>But the heart of the backup system lies in two fundation classes: the
  File-related and the List-related classes.</p>

  <h3>File-related classes</h3>

  <p>The basic class is Node, which provides ways to get and stores the file
  metadata.</p>

  <p>From this derive three classes:</p>
  <ul>
  <li>Directory: this class adds a list of entries in the directory</li>
  <li>File: this class adds a checksum field</li>
  <li>Link: this class adds linked file management</li>
  </ul>

  <p>From File derives one class Stream which adds methods to:</p>
  <ul>
  <li>compute checksums</li>
  <li>read/write/copy/compare binary files (with checksum calculation)</li>
  <li>read and decode a line</li>
  </ul>

  <h3>List-related class</h3>

  <p>This list is at the very heart of the backup database management.
  Explaining its methods might require a document by itself!</p>